Unit XT_Testing;
{=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=]
 Copyright (c) 2013, Jarl K. <Slacky> Holta || http://github.com/WarPie
 All rights reserved.
 For more info see: Copyright.txt
[=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=}
interface

uses
  XT_Types, XT_Math, Math, SysUtils;

function ALPHA_ClusterTPAEx(const TPA: TPointArray; Distx,Disty: Integer; EightWay:Boolean): T2DPointArray; StdCall;



//--------------------------------------------------
implementation

uses 
  XT_Collection, XT_Points, XT_TPAStack;


{*
 ClusterTPA is a `complex` function, it's action is the same as SplitTPA(Ex) seen in
 Simba, and SCAR (Macro-programs), but unlike those, this one performce in O(n)-time, while
 SplitTPA(ex) has a time-complexity of O(n^2).
 
 In short this algorithm uses a 2D-Matrix to cluster together the points that are 
 within a given distance (Distx,Disty) from each other. It then returns 2D TPoint Array (T2DPointArray).
*}
function ALPHA_ClusterTPAEx(const TPA: TPointArray; Distx,Disty: Integer; EightWay:Boolean): T2DPointArray; StdCall;
var
  W,H,i,x,y,rw,rh,x1,y1:Integer;
  R,qsize,fsize,Count,S,j,L:Integer;
  Area:TBox;
  Matrix,Table:T2DIntArray;
  face:TPointArray;
  Queue: TPAStack;
  pt,adj,testpt:TPoint;
begin
  Area := TPABounds(TPA);
  Area.x1 := Area.x1 - 3;
  Area.y1 := Area.y1 - 3;
  W := (Area.x2 - Area.x1) + 1;
  H := (Area.y2 - Area.y1) + 1;
  if Distx > W then Distx := W;
  if Disty > H then Disty := H;
  RH := H-1;
  RW := W-1;
  Count := 0;
  L := High(TPA);
  SetLength(Matrix, H+2, W+2);

  //-----------
  //Method depends on a lot of things, tho I just estimate it..
  case (((RW*RH)*8) < (L*(Distx+Disty))) of
   False:
    begin
      for i:=0 to L do
      begin
        pt.x := (TPA[i].x - Area.X1);
        pt.y := (TPA[i].y - Area.Y1);
        x1 := Min(RW, pt.x + DistX - 1);
        y1 := Min(RH, pt.y + DistY - 1);
        for x:=pt.x to x1 do begin
          Matrix[pt.y][x] := -2;
          Matrix[y1][x] := -2;
        end;
        for y:=pt.y to y1 do begin
          Matrix[y][pt.x] := -2;
          Matrix[y][x1] := -2;
        end;
      end;
    end;

   True:
    begin
      SetLength(Table, (H+2), (W+2));
      for i:=0 to L do
      begin
        x := (TPA[i].x - Area.X1);
        y := (TPA[i].y - Area.Y1);
        Matrix[y][x] := 1;
        Table[y][x+1] := 1;
      end;
      for y:=0 to RH do
        for x:=0 to RW do
          Table[y+1][x+1] := (Table[y+1][x] + Table[y][x+1] - Table[y][x] + Matrix[y][x]);
      for y:=1 to RH do begin
        y1 := Min(H, y + DistY);
        for x:=1 to RW do begin
          x1 := Min(W, x + DistX);
          R := (Table[y][x] + Table[y1][x1] - Table[y1][x] - Table[y][x1]);
          if R > 0 then begin
            Matrix[y][x] := -2;
          end else
            Matrix[y][x] := -99;
        end;
      end;
      SetLength(Table, 0);
    end;
  end;


  //--------------
  //Simply floodfill the resulting boxes.
  qsize := L;
  Queue := TPAStack.Init;
  
  fsize := 7;
  if EightWay = False then fsize := 3;
  SetLength(Face, fsize+1);

  for i:=0 to L do
  begin
    pt.x := (TPA[i].x - Area.X1);
    pt.y := (TPA[i].y - Area.Y1);
    if Matrix[pt.y][pt.x] = -2 then
    begin
      Matrix[pt.y][pt.x] := Count;
      Queue.Append(pt);
      S := 1;
      while Queue.NotEmpty do
      begin
        GetAdjacent(Face, Queue.Pop, EightWay);
        for j:=0 to fsize do
        begin
          adj := face[j];
          if Matrix[adj.y][adj.x] = -2 then
          begin
            Matrix[adj.y][adj.x] := Count;
            Queue.Append(Adj);
          end;
        end;
      end;
      Count := Count + 1;
    end;
  end;
  SetLength(Face, 0);
  Queue.Free;
  
  //-----------
  // Creating the result.
  SetLength(Result, Count);
  SetLength(Table, Count, 2);
  for i:=0 to L do
  begin
    pt := TPA[i];
    J := Matrix[(pt.y-Area.Y1)][(pt.x-Area.X1)];
    if J >= 0 then
    begin
      S := Table[J][0];
      Inc(Table[J][1]);
      R := Table[J][1];
      if S <= R then
      begin
        Table[J][0] := R+R;
        SetLength(Result[J], R+R+1);
      end;
      Result[J][R-1] := PT;
    end;
  end;
  for i:=0 to Count-1 do
    SetLength(Result[I], Table[i][1]);

  SetLength(Table, 0);
  SetLength(Matrix, 0);
end;

end.
