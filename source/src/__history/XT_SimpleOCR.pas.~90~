Unit XT_SimpleOCR;
{=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=]
 Copyright (c) 2013, Jarl K. <Slacky> Holta || http://github.com/WarPie
 All rights reserved.
 For more info see: Copyright.txt
[=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=}
//SCARs GetTextAtEx was running to slow, and missing tolerance for pixel error.
//This is just something I wrote very fast, so it's very prototype-ish.
//Might be expanded on over time.
interface
uses
  XT_Types, Math, XT_Math, SysUtils;

function ImGetText(ImgArr:T2DIntArray; Font:TChars; MinCharSpace, MinSpace, TextPixTol: Integer; Range:AnsiString): AnsiString; StdCall;
function ImGetTextEx(ImgArr:T2DIntArray; Fonts:TCharsArray; MinCharSpace, MinSpace, TextPixTol: Integer; Range:AnsiString): AnsiString; StdCall;
function SimpleOCR(const ImgArr:T2DIntArray; Color, Tol:Integer; const Chars: TCharsN; Quick, Careless: Boolean): AnsiString; StdCall;
function OCRFirstChar(const TPA:TPointArray; const Chars: TCharsN; Tol:Integer; Quick, CareLess: Boolean; var MarkBad: Boolean): Integer; Inline; StdCall;


//--------------------------------------------------
implementation
uses 
  XT_Matrix, XT_Sorting, XT_Points, XT_Imaging, XT_Finder;

var
  SpacePositions: TBoolArray;
  

function ExtractChars(ImgArr:T2DIntArray; MinCharSpace, MinSpace:Integer): TChars;
var
  i,j,H:Integer;
  TPA: TPointArray;
  ATPA: T2DPointArray;
  B,PB: TBox;
begin
  ImgArr := ImThresholdAdaptive(ImgArr, 0, 255, False, TM_Mean, 0);
  ImFindColorTolEx(ImgArr, TPA, 255, 1);
  ATPA := ClusterTPAEx(TPA, MinCharSpace, 2, True);
  H := High(ATPA); 
  SetLength(SpacePositions, H+1);
  SetLength(Result, H+1);   
  for i:=0 to H do 
  begin
    B := TPABounds(ATPA[i]); 
    if (i>0) then
      if (Abs(B.x1 - PB.x2)-2) > MinSpace then
        SpacePositions[i] := True;
    PB := B; 

    SetLength(Result[i], (B.y2 - B.y1)+1, (B.x2 - B.x1)+1);
    for j:=0 to High(ATPA[i]) do
      Result[i][ATPA[i][j].y - B.y1][ATPA[i][j].x - B.x1] := 255; 
  end;
  SetLength(ATPA, 0);
end;


function CompareChars(CharA,CharB: T2DIntArray): Integer; Inline;
var x,y,W,H,hits:Integer;
begin
  H := Min(High(CharA), High(CharB));
  W := Min(High(CharA[0]), High(CharB[0])); 
  
  hits := 0;
  for y:=0 to H do 
    for x:=0 to W do     
      if ((CharA[y][x] - CharB[y][x]) <> 0) then
        Inc(hits); 

  hits := hits + Abs(High(CharA) - High(CharB));
  hits := hits + Abs(High(CharA[0]) - High(CharB[0])); 
  Result := hits;
end;


function ImGetText(ImgArr:T2DIntArray; Font:TChars; MinCharSpace, MinSpace, TextPixTol: Integer; Range:AnsiString): AnsiString; StdCall;
var
  i,j:Integer;
  PixHits,char,hit:Integer; 
  Chars: TChars; 
begin
  Chars := ExtractChars(ImgArr, MinCharSpace, MinSpace);

  Result := '';  
  for i:=0 to High(Chars) do
  begin
    Char := 0;
    PixHits := 10000000;   
    
    for j:=0 to High(Font) do
    begin          
      if High(font[j]) < 0 then Continue;
      hit := CompareChars(chars[i], font[j]); 
      if hit < PixHits then 
      begin 
        PixHits := hit;
        Char := j;
      end;
    end;
    
    if SpacePositions[i] then 
      Result := Result + ' ';
    if (PixHits < TextPixTol) then    
      Result := Result + Chr(Char)
    else
      Result := Result + ''; //Unkown char  
  end;
  
  SetLength(SpacePositions, 0);
end;  


(* 
 Taking multple fonts and using that to try to read some text.
*) 
function ImGetTextEx(ImgArr:T2DIntArray; Fonts:TCharsArray; MinCharSpace, MinSpace, TextPixTol: Integer; Range:AnsiString): AnsiString; StdCall;
var
  i,j,k,highFonts:Integer;
  PixHits,char,hit:Integer; 
  Chars: TChars; 
begin
  Chars := ExtractChars(ImgArr, MinCharSpace, MinSpace);
  HighFonts := High(Fonts);
  Result := '';  
  for i:=0 to High(Chars) do
  begin
    Char := 0;
    PixHits := 10000000;   
    
    for k:=0 to HighFonts do
    begin
      for j:=0 to high(Fonts[k]) do
      begin          
        if High(fonts[k][j]) < 0 then Continue;
        hit := CompareChars(chars[i], Fonts[k][j]); 
        if (hit < PixHits) then 
        begin 
          PixHits := hit;
          Char := j;
        end;
      end;
    end;  
    
    if SpacePositions[i] then 
      Result := Result + ' ';

    if (PixHits < TextPixTol) then
      Result := Result + Chr(Char)
    else
      Result := Result + ''; //Unkown char  
  end;
  
  SetLength(SpacePositions, 0);
end; 




///----------------------------  ALPHA  STATE  -------------------------------\\
function CopyTPA(const TPA:TPointArray): TPointArray; Inline;
var i: Integer;
begin
  SetLength(Result, Length(TPA));
  for i := 0 to High(TPA) do
    Result[i] := TPA[i];
end;


//Nearest neigbour comparison (dirty)
function NearestMatch(const Char: TCharN; Shadows:TPointArray; Quick, CareLess: Boolean): Integer; Inline;
var 
  i,H,Bx,By: Integer;
  TPA:TPointArray;
  pt: TPoint;
begin
  Result := 99999999; 
  if (High(Char.Pts) = -1) or (High(Shadows) <= 0) then Exit;
  Result := 0;
  TPA := CopyTPA(Char.Pts);

  case Careless of         
    False: begin
      //OffsetTPA(TPA, (Shadows[0].x - TPA[0].x), 0);
      Bx := (Shadows[0].x - TPA[0].x);
      By := 0;
    end;
    True: begin
      //OffsetTPA(TPA, (Shadows[0].x - TPA[0].x), (Shadows[0].y - TPA[0].y));
      Bx := (Shadows[0].x - TPA[0].x);
      By := (Shadows[0].y - TPA[0].y);
    end;
  end;
  
  H := Min(High(TPA), High(Shadows)); 
  case Quick of
    True:
      for i:=0 to H do
      begin
        pt := Point(TPA[i].x+Bx, TPA[i].y+By);
        Result := Result + Round(DistEuclidean(pt,Shadows[i]));
      end;
    False:
      for i:=0 to H do
      begin
        pt := Point(TPA[i].x+Bx, TPA[i].y+By);
        SortTPAFrom(Shadows, pt); 
        Result := Result + Round(DistEuclidean(pt,Shadows[0]));
      end;
  end;     
end;


function OCRFirstChar(const TPA:TPointArray; const Chars: TCharsN; Tol:Integer; Quick, CareLess: Boolean; var MarkBad: Boolean): Integer; Inline; StdCall;
var
  i,HighChars,len,nearest: Integer;
  Matches, Filtered: TIntArray;
begin
  HighChars := High(Chars);
  SetLength(Matches, HighChars+1);
  for i:=0 to HighChars do
  begin
    Matches[i] := NearestMatch(Chars[i], CopyTPA(TPA), Quick, CareLess);
  end;
    
  for i:=0 to HighChars do
  begin
    if Matches[i] <= tol then
    begin
      len := Length(Filtered);
      SetLength(Filtered, len+1);
      Filtered[len] := i;
    end;
  end;
     
  Len := -1;
  Nearest := 0; 
  for i:=0 to High(Filtered) do
  begin 
    if Length(Chars[Filtered[i]].Pts) > len then
    begin
      Len := Length(Chars[Filtered[i]].Pts);
      Nearest := Filtered[i]; 
    end;
  end;

  Result := -1;
  if (Len > 0) then 
  begin 
    Result := Nearest;
    if Tol>=2 then 
      if (Result=39) or (Result=44) or (Result=46) or 
         (Result=58) or (Result=59) then
        MarkBad := True;
  end; 
end;


function SimpleOCR(const ImgArr:T2DIntArray; Color, Tol:Integer; const Chars: TCharsN; Quick, Careless: Boolean): AnsiString; StdCall;
var
  i,W,H,c: Integer;
  Inablity,Miss: Integer;
  MarkBad: Boolean;
  R: Char;
  Char: TCharN;
  TPA:TPointArray;
  ATPA:T2DPointArray;
  B,PB:TBox;
begin
  H := Chars[32].Height;
  W := Length(ImgArr[0]);
  ImFindColorTolEx(ImgArr, TPA, Color, Tol);
  if High(TPA) = -1 then Exit;

  if Careless then
  begin
    ATPA := ClusterTPAEx(TPA,20,1,False);
    ATPAFilter(ATPA, 1,2,2,W,15,True);
    TPA := MergeATPA(ATPA);
    B := TPABounds(TPA);
    OffsetTPA(TPA, -B.x1+3,-B.y1+1);
    H := Min(Chars[32].Height+1,B.y2+1);
  end;
  TPAFilterBounds(TPA, 0,0,W-1, H);
  if High(TPA) = -1 then Exit;
  SortTPAByColumn(TPA);


  B.X2 := 1;
  Miss := 0;
  Inablity := 0;
  for i:=0 to 1000 do
  begin
    MarkBad := False;
    case i of
      0:  TPAFilterBounds(TPA, 2, 0, W-1, H);  //W
      1:  TPAFilterBounds(TPA, 14, 0, W-1, H); //a
      2:  TPAFilterBounds(TPA, 20, 0, W-1, H); //l
      3:  TPAFilterBounds(TPA, 25, 0, W-1, H); //k
      else Exit;
    end;

    if Length(TPA) = 0 then Break;
    C := OCRFirstChar(TPA, Chars, Inablity, Quick, CareLess, MarkBad);
    if C = -1 then
    begin
      Inc(Miss);
      Inc(Inablity);
    end else
    begin
      PB := B;
      Char := Chars[C];
      //if Length(Char.Pts) = 0 then Break;

      //B.X1 := (Char.x1) + (TPA[0].x - Char.Pts[0].x)-1;
      //B.X2 := (Char.x2) + (TPA[0].x - Char.Pts[0].x);
      //B.y1 := 0;
      //B.y2 := H - 1;
      if (not(MarkBad)) and (Inablity=0) then
      begin
        R := Chr(C);
        //if i>0 then
        //  if ((B.x1 - PB.x2)-2) >= 2 then
        //    Result := Result + ' ';
        Result := Result + R;
      end;
      Tol := 0;
    end;
    if (Miss >= 80) then Break;
  end;
end;


end.