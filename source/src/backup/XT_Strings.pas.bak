unit XT_Strings;
{=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=]
 Copyright (c) 2013, Jarl K. <Slacky> Holta || http://github.com/WarPie
 All rights reserved.
 For more info see: Copyright.txt
[=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=}
{$mode objfpc}{$H+}
{$macro on}
interface

uses
  SysUtils,
  XT_Types;

function StrPosEx(const Text, SubStr:String): TIntArray; Cdecl;
function StrReplace(const Text, SubStr, RepStr: String; Flags:TReplaceFlags): String; Cdecl;


//-----------------------------------------------------------------------
implementation

{*
 Returns all positions of the given pattern/substring.
*}
function StrPosEx(const Text: String; const SubStr:String): TIntArray; Cdecl;
var
  hits,maxhits,h,q,i: Integer;
begin
  MaxHits := Length(SubStr);
  Hits := 1;
  h := 0;
  q := 1;
  SetLength(Result, q);
  for i:=1 to Length(Text) do
  begin
    if Text[i] = SubStr[Hits] then
    begin
      Inc(Hits);
      if (Hits > MaxHits) then
      begin
        if q <= h  then
        begin
          q := q+q;
          SetLength(Result, q);
        end;
        Result[h] := (i - Hits) + 1;
        Inc(h);
        Hits := 1;
      end;
    end else
      Hits := 1;
  end;
  SetLength(Result, h);
end;


{*
 Fast string replace.
*}
function StrReplace(const Text, SubStr, RepStr: String; Flags:TReplaceFlags): String; Cdecl;
var
  Hi,HiSub,HiRep,i,j,k: Integer;
  Prev,Curr:Integer;
  Subs: TIntegerArray;
begin
  Hi := Length(Text);
  if Hi = 0 then Exit;
  case (rfIgnoreCase in flags) of
    True: Subs := StrPosEx(LowerCase(Text), LowerCase(SubStr));
    False:Subs := StrPosEx(Text, SubStr);
  end;

  if Length(Subs) = 0 then
    Exit(Copy(Text, 1,Hi));

  HiRep := Length(RepStr);
  HiSub := Length(SubStr);

  SetLength(Result, Hi + (Length(Subs) * (HiRep-HiSub)));
  k := 1;
  Prev := 1;
  case (rfReplaceAll in Flags) of
  True:
    begin
      for i:=0 to High(Subs) do
      begin
        Curr := Subs[i];
        j := (Curr-Prev) + 1;
        Move(Text[Prev], Result[k], j);
        k := k + j;
        Move(RepStr[1], Result[k], HiRep);
        k := k+HiRep;
        Prev := Curr + HiSub + 1;
      end;
      Move(Text[Prev], Result[k], Hi-Prev+1);
    end;
  False:
    begin
      Curr := Subs[0];
      j := (Curr-Prev) + 1;
      Move(Text[Prev], Result[k], j);
      k := k + j;
      Move(RepStr[1], Result[k], HiRep);
      k := k+HiRep;
      Prev := Curr + HiSub + 1;
      Move(Text[Prev], Result[k], Hi-Prev+1);
      SetLength(Result, k+(Hi-Prev)+1);
    end;
  end;
end;


end.
